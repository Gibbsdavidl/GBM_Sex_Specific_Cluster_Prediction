---
title: An R Markdown document converted from "STEP_3_Feature_Selection_Processing_V3.ipynb"
output: html_document
---

```{r}
#devtools::install_github("gibbsdavidl/robencla", force = F)
```

```{r}
library(tidyverse)
```

First to read in the data and the feature selection metrics.


```{r}

#array_f  <- read_csv('../data/jive_training_array_data_F.csv.gz')
load('../data/F_processed_data.rda')

resdf_f <- read_csv('../results/feature_selection_table_female.csv.gz')

# drop the first column of row numbers
#array_f <- array_f[,-1]

table(resdf_f$cluster)

```

Then we can bring in the gene symbols

```{r}

# don't count the annotation columns at the end
array_ncol <- ncol(dat_f)-3

# get gene IDs from the array
genesi <- colnames(dat_f)[resdf_f$gene_i]
genesj <- colnames(dat_f)[resdf_f$gene_j]

# start a new table
annotdf_f <- resdf_f
annotdf_f['gene_i_symbol'] <- genesi
annotdf_f['gene_j_symbol'] <- genesj

# compute the ranking score
score <- abs(annotdf_f$prop_diff)*(-1*annotdf_f$avg_dist_cluster*annotdf_f$avg_dist_not_cluster)
annotdf_f$score <- score

write.csv(annotdf_f, file = '../results/annotdf_f.csv.gz')
```

Next we rank the gene pair selection metrics and take the best!


```{r}



### number of pairs that we want.
wanted_pairs <- 16

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- annotdf_f[(annotdf_f$cluster == this_cluster),]

  # then we get the ordering index
  idx <- order(pairs$score, decreasing = T)
  pairsord <- pairs[idx,]
  
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], 
                    g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], 
                    iv=pairsord$score[1])
  
  kmax <- nrow(pairsord)
  k <- 2 # decending the ordered pairs table
  
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, 
                      g1=pairsord$gene_i_symbol[k], 
                      g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], 
                      iv=pairsord$score[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_f, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/females_genepairs.rda')
  
```











```{r}

#array_m <- read_csv('../data/jive_training_array_data_M.csv.gz')

load('../data/M_processed_data.rda')
resdf_m <- read_csv('../results/feature_selection_table_male.csv.gz')

table(resdf_m$cluster)

#print(tail(colnames(dat_m)))
#[1]     "SCO2"         "Barcode"      "ClusterLabel"  "Sex"
```



Then we can bring in the gene symbols

```{r}

# don't count the annotation columns at the end
array_ncol <- ncol(dat_m)-3

# get gene IDs from the array
genesi <- colnames(dat_m)[resdf_m$gene_i]
genesj <- colnames(dat_m)[resdf_m$gene_j]


annotdf_m <- resdf_m
annotdf_m['gene_i_symbol'] <- genesi
annotdf_m['gene_j_symbol'] <- genesj

table(annotdf_m$cluster)

annotdf_m <- annotdf_m[(annotdf_m$gene_j_symbol != 'Barcode'),]

score <- abs(annotdf_m$prop_diff)*(-1*annotdf_m$avg_dist_cluster*annotdf_m$avg_dist_not_cluster)
annotdf_m$score <- score

write.csv(annotdf_m, file = '../results/annotdf_m.csv.gz')
```

Next we rank the gene pair selection metrics and take the best!


```{r}

### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- annotdf_m[(annotdf_m$cluster == this_cluster),]

  # then we get the ordering index
  idx <- order(pairs$score, decreasing = T)
  pairsord <- pairs[idx,]
  
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], 
                    g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], 
                    iv=pairsord$score[1])
  
  kmax <- nrow(pairsord)
  k <- 2 # decending the ordered pairs table
  
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, 
                      g1=pairsord$gene_i_symbol[k], 
                      g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], 
                      iv=pairsord$score[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_m, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/males_genepairs.rda')
  
```























