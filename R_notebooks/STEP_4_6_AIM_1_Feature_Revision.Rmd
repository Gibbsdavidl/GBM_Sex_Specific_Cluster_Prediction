---
title: "Feature revision"
output: html_notebook
---

After the JIVE validation, we saw that some features do not reproduce well
in the validation studies. We will try to revise the selection to find
concordance.

```{r}
library(tidyverse)
library(robencla)
library(survminer)
library(survival)

```



```{r}




# Take the data set, and filter out pair genes that are not present.

clean_genepairs_list <- function(genepairs, dat_x) {
  genepairs_clean <- list()
  i <- 1
  for (pi in names(genepairs)) {
    genes <- genepairs[[pi]]
    missing_genes <- unique( genes [! genes %in% colnames(dat_x)] )
    print(paste0(pi, '  ', missing_genes))
    newpairlist <- c()
    for (j in seq.int(from=1,to=length(genes), by=2)) {
      if ( (genes[j] %in% missing_genes) | (genes[j+1] %in% missing_genes) ) {
        # then don't add them!
        print(paste0("removing from pair list:  ", genes[j], ' ', genes[j+1]))
      } else {
        newpairlist <- c(newpairlist, genes[j], genes[j+1])
      }
    }
    genepairs_clean[[pi]] <- newpairlist
  }
  return(genepairs_clean)
}

# pairlist is a list of vectors (paired terms)
# n is the number of pairs for each entry desired

shorter_and_clean <- function(pairlist, n) {
  newlist <- list()
  for (ni in names(pairlist)) {
    newlist[[ni]] <- str_replace_all(pairlist[[ni]][1:(2*n)], '\\.', '_')
  }
  return(newlist)  
}


```

```{r}

load('../data/F_processed_data.rda')
load('../results/females_genepairs.rda')
resdf <- read_csv('../results/annotdf_f.csv.gz')
rclin <- read.csv('../data/Array Data/validation_array_resources/GSE108475_REMBRANDT_clinical.data.csv')

```


Now we can check the prop_diff between the training and testing data


```{r}

val_prop_diff <- c()
dat_prop_diff <- c()

this_label <- 'cluster1'
gp_cl <- genepairs[[this_label]]

for (rowi in seq.int(from=1, to = length(gp_cl), by = 2)) {

  # gene symbols
  #g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  #g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  g1 <- gp_cl[rowi]
  g2 <- gp_cl[rowi+1]
  
  if (g1 %in% colnames(val_dat) && g2 %in% colnames(val_dat)) {
    #  index into this cluster
    idx <- val_dat$ClusterLabel == this_label
    jdx <- val_dat$ClusterLabel != this_label
    
    # data labeled as THIS cluster
    labdat <- val_dat[idx,]
    # data labels as NOT THIS cluster
    notdat <- val_dat[jdx,]
    
    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
    
    # get the row for this gene pair
    resdf_idx <- which(resdf$cluster == this_label & resdf$gene_i_symbol == g1 & resdf$gene_j_symbol == g2)
    
    val_prop_diff <- c(val_prop_diff, prop1 - prop2)
    dat_prop_diff <- c(dat_prop_diff, resdf$prop_diff[resdf_idx])
  
  } else {
    print(
      "not found"
    )
  }
}

resdf[29077,c('cluster','pair','gene_i_symbol', 'gene_j_symbol', 'prop_diff')]

qplot(x=dat_prop_diff, y=val_prop_diff)

```


VAL ARRAY


```{r}

val_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))
tra_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))

last_label <- "asdf"

for (rowi in 1:nrow(resdf)) {
  
  if(rowi %% 1000 == 0){
    print(rowi)
  }

  this_label <- as.character(resdf$cluster[rowi])

  if (this_label != last_label) {
    #  index into this cluster
    idx <- val_dat$ClusterLabel == this_label
    jdx <- val_dat$ClusterLabel != this_label
    kdx <- dat_f$ClusterLabel == this_label
    ldx <- dat_f$ClusterLabel != this_label
    
    # data labeled as THIS cluster
    labdat <- val_dat[idx,]
    # data labels as NOT THIS cluster
    notdat <- val_dat[jdx,]
    # data labeled as THIS cluster
    labdat_tra <- dat_f[kdx,]
    # data labels as NOT THIS cluster
    notdat_tra <- dat_f[ldx,]
    
    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
        # number of samples in each category
    p <- sum(kdx)
    q <- sum(ldx)
  }
  
  # gene symbols
  g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  if (g1 %in% colnames(val_dat) & g2 %in% colnames(val_dat)) {
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
        # proportion of samples showing pattern gene1 > gene2    
    prop3 <- (sum(labdat_tra[, ..g1] > labdat_tra[, ..g2])/p) # proportion i>j in this cluster
    prop4 <- (sum(notdat_tra[, ..g1] > notdat_tra[, ..g2])/q) # proportion i>j in others
    
    val_prop_diff[rowi] <- prop1 - prop2
    tra_prop_diff[rowi] <- prop3 - prop4
  
  } else {
    val_prop_diff[rowi] <- NA
    tra_prop_diff[rowi] <- NA

  }
  
  last_label <- this_label
}

#resdf$val_prop_diff <- val_prop_diff

#write_csv(resdf, file='../results/annotdf_f_valdiff.csv')

```






RNA 






```{r}

rna_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))

last_label <- "asdf"

for (rowi in 1:nrow(resdf)) {
  
  if(rowi %% 1000 == 0){
    print(rowi)
  }

  this_label <- as.character(resdf$cluster[rowi])

  if (this_label != last_label) {
    #  index into this cluster
    idx <- tcga_f$cluster.group == this_label
    jdx <- tcga_f$cluster.group != this_label
    
    # data labeled as THIS cluster
    labdat <- as.data.table(tcga_f[idx,])
    # data labels as NOT THIS cluster
    notdat <- as.data.table(tcga_f[jdx,])

    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
  }
  
  # gene symbols
  g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  if (g1 %in% colnames(tcga_f) & g2 %in% colnames(tcga_f)) {
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
        
    rna_prop_diff[rowi] <- prop1 - prop2

  } else {
    rna_prop_diff[rowi] <- NA
  }
  
  last_label <- this_label
}

resdf$rna_prop_diff <- rna_prop_diff

#write_csv(resdf, file='../results/annotdf_f_valdiff.csv')



df <- resdf[, c('cluster','pair','gene_i_symbol', 'gene_j_symbol', 'prop_diff', 'rna_prop_diff')]

df[29077,]

idx <- sample(1:356000, size=1000)

qplot(x=df$prop_diff[idx], y=df$rna_prop_diff[idx])
head(df)
```


Update the score ranking by looking for alignment between the val array and tcga array data


```{r}



### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


# preparing for the scoring

x <- resdf$avg_dist_cluster
resdf$norm_avg_dist_cluster <- (  (x-median(x)) / (max(x) - min(x))  )
y <- resdf$avg_dist_not_cluster
resdf$norm_avg_dist_not_cluster <- (  (y-median(y)) / (max(y) - min(y))  )


# create the values that will be used to order pairs.
score0 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


# create the values that will be used to order pairs.
score1 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (1 - abs(resdf$prop_diff - resdf$val_prop_diff))*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


resdf$score2 <- (score1 + abs(min(score1, na.rm = T))) / abs(max(score1,na.rm = T))

scoredf <- data.frame(score0=score0, score1=score1)
idx <- sample(1:356000, size=10000)
ggplot(data=scoredf[idx,], aes(y=score1, x=score0)) + geom_point() + xlim(c(0,1.1)) +  ylim(c(0,1.1)) + geom_abline()


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- resdf[(resdf$cluster == this_cluster),]
  
  min_i_tval <- quantile(pairs$gene_i_min, na.rm=T)['50%']
  min_j_tval <- quantile(pairs$gene_j_min, na.rm=T)['50%']


  pairs <- pairs[(pairs$gene_i_min > min_i_tval) &
                 (pairs$gene_j_min > min_j_tval),]


  # then we get the ordering index
  idx <- order(pairs$score2, decreasing = T)
  pairsord <- pairs[idx,]
  
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], iv=pairsord$score2[1])
  
  kmax <- nrow(pairsord)

  k <- 2 # decending the ordered pairs table
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, g1=pairsord$gene_i_symbol[k], g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], iv=pairsord$score2[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_f, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/females_genepairs_val.rda')
  
```



```{r}



### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


# preparing for the scoring

x <- resdf$avg_dist_cluster
resdf$norm_avg_dist_cluster <- (  (x-median(x)) / (max(x) - min(x))  )
y <- resdf$avg_dist_not_cluster
resdf$norm_avg_dist_not_cluster <- (  (y-median(y)) / (max(y) - min(y))  )


# create the values that will be used to order pairs.
score0 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


# create the values that will be used to order pairs.
score1 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (1 - abs(resdf$prop_diff - resdf$rna_prop_diff))*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


resdf$score2 <- (score1 + abs(min(score1, na.rm = T))) / abs(max(score1,na.rm = T))

scoredf <- data.frame(score0=score0, score1=score1)
idx <- sample(1:356000, size=10000)
ggplot(data=scoredf[idx,], aes(y=score1, x=score0)) + geom_point() + xlim(c(0,1.1)) +  ylim(c(0,1.1)) + geom_abline()


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- resdf[(resdf$cluster == this_cluster),]
  
  #min_i_tval <- quantile(pairs$gene_i_min, na.rm=T)['50%']
  #min_j_tval <- quantile(pairs$gene_j_min, na.rm=T)['50%']


  #pairs <- pairs[(pairs$gene_i_min > min_i_tval) &
  #               (pairs$gene_j_min > min_j_tval),]


  # then we get the ordering index
  idx <- order(pairs$score2, decreasing = T)
  pairsord <- pairs[idx,]
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], pr=pairsord$rna_prop_diff[k],
                    sc=pairsord$score2[1])
  
  kmax <- nrow(pairsord)

  k <- 2 # decending the ordered pairs table
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, g1=pairsord$gene_i_symbol[k], g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], pr=pairsord$rna_prop_diff[k],
                      sc=pairsord$score2[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_f, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/females_genepairs_rna.rda')
  
```






 MEN
 MEN
 MEN
 MEN
 MEN
 MEN
 MEN
 MEN





First we load the array data, the validation data, the pairs table,
the selected gene pairs.



```{r}

load('../data/M_processed_data.rda')
load('../data/m_genepairs.rda')
rclin <- read.csv('../data/Array Data/validation_array_resources/GSE108475_REMBRANDT_clinical.data.csv')

genepairs <- m_genepairs$val
gpairs <- shorter_plist(genepairs, 24)

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, val_m)  # only one with missing genes


# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=6,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.3,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_m <- robencla::Robencla$new('m_model')


mod_m$train(data_frame=dat_m,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'Barcode',
            drop_list = c('Sex'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_m$predict(data_frame = val_m, 
              sample_id = 'Barcode')


# get the results table
resdf <- mod_m$results()

# add in the survival and censored
resdf$Survival <- mod_m$test_data$Survival
resdf$Censored <- mod_m$test_data$Censored

# convert scores to numerics
resdf$cluster1 <- unlist(resdf$cluster1)
resdf$cluster2 <- unlist(resdf$cluster2)
resdf$cluster3 <- unlist(resdf$cluster3)
resdf$cluster4 <- unlist(resdf$cluster4)
resdf$cluster5 <- unlist(resdf$cluster5)

head(resdf)

df <- inner_join(resdf, rclin, join_by('SampleIDs'=='SUBJECT_ID'))

table(df$BestCalls, df$DISEASE_TYPE)




resdf$CensoredCode <- ifelse(resdf$Censored == 0, yes=1, no=2)

modfit <- survfit(Surv(Survival, CensoredCode)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T, xlim=c(0,1700))




write.csv(resdf, file='../results/M_validation_predictions_using_rna_pairs.csv')




```



```{r}

val_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))
tra_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))

last_label <- "asdf"

for (rowi in 1:nrow(resdf)) {
  
  if(rowi %% 1000 == 0){
    print(rowi)
  }

  this_label <- as.character(resdf$cluster[rowi])

  if (this_label != last_label) {
    #  index into this cluster
    idx <- val_dat$ClusterLabel == this_label
    jdx <- val_dat$ClusterLabel != this_label
    kdx <- dat_m$ClusterLabel == this_label
    ldx <- dat_m$ClusterLabel != this_label
    
    # data labeled as THIS cluster
    labdat <- val_dat[idx,]
    # data labels as NOT THIS cluster
    notdat <- val_dat[jdx,]
    # data labeled as THIS cluster
    labdat_tra <- as.data.table(dat_m[kdx,])
    # data labels as NOT THIS cluster
    notdat_tra <- as.data.table(dat_m[ldx,])
    
    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
        # number of samples in each category
    p <- sum(kdx)
    q <- sum(ldx)
  }
  
  # gene symbols
  g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  if (g1 %in% colnames(val_dat) & g2 %in% colnames(val_dat)) {
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
        # proportion of samples showing pattern gene1 > gene2    
    prop3 <- (sum(labdat_tra[, ..g1] > labdat_tra[, ..g2])/p) # proportion i>j in this cluster
    prop4 <- (sum(notdat_tra[, ..g1] > notdat_tra[, ..g2])/q) # proportion i>j in others
    
    val_prop_diff[rowi] <- prop1 - prop2
    tra_prop_diff[rowi] <- prop3 - prop4
  
  } else {
    val_prop_diff[rowi] <- NA
    tra_prop_diff[rowi] <- NA

  }
  
  last_label <- this_label
}

resdf$val_prop_diff <- val_prop_diff

write_csv(resdf, file='../results/annotdf_m_valdiff.csv')

```



```{r}



### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


# preparing for the scoring

x <- resdf$avg_dist_cluster
resdf$norm_avg_dist_cluster <- (  (x-median(x)) / (max(x) - min(x))  )
y <- resdf$avg_dist_not_cluster
resdf$norm_avg_dist_not_cluster <- (  (y-median(y)) / (max(y) - min(y))  )


# create the values that will be used to order pairs.
score0 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


# create the values that will be used to order pairs.
score1 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (1 - abs(resdf$prop_diff - resdf$val_prop_diff))*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


resdf$score2 <- (score1 + abs(min(score1, na.rm = T))) / abs(max(score1,na.rm = T))

scoredf <- data.frame(score0=score0, score1=score1)
idx <- sample(1:109000, size=10000)
ggplot(data=scoredf[idx,], aes(y=score1, x=score0)) + geom_point() + xlim(c(0,1.1)) +  ylim(c(0,1.1)) + geom_abline()


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- resdf[(resdf$cluster == this_cluster),]
  
  min_i_tval <- quantile(pairs$gene_i_min, na.rm=T)['50%']
  min_j_tval <- quantile(pairs$gene_j_min, na.rm=T)['50%']


  pairs <- pairs[(pairs$gene_i_min > min_i_tval) &
                 (pairs$gene_j_min > min_j_tval),]


  # then we get the ordering index
  idx <- order(pairs$score2, decreasing = T)
  pairsord <- pairs[idx,]
  
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], iv=pairsord$score2[1])
  
  kmax <- nrow(pairsord)

  k <- 2 # decending the ordered pairs table
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, g1=pairsord$gene_i_symbol[k], g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], iv=pairsord$score2[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_m, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/males_genepairs_val.rda')
  
```



RNA 

```{r}

load('../data/M_processed_data.rda')

resdf <- read_csv(file='../results/annotdf_m_valdiff.csv.gz')

rna_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))

last_label <- "asdf"

for (rowi in 1:nrow(resdf)) {
  
  if(rowi %% 1000 == 0){
    print(rowi)
  }

  this_label <- as.character(resdf$cluster[rowi])

  if (this_label != last_label) {
    #  index into this cluster
    idx <- rna_m$ClusterLabel == this_label
    jdx <- rna_m$ClusterLabel != this_label
    
    # data labeled as THIS cluster
    labdat <- as.data.table(rna_m[idx,])
    # data labels as NOT THIS cluster
    notdat <- as.data.table(rna_m[jdx,])

    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
  }
  
  # gene symbols
  g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  if (g1 %in% colnames(rna_m) & g2 %in% colnames(rna_m)) {
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
        
    rna_prop_diff[rowi] <- prop1 - prop2

  } else {
    rna_prop_diff[rowi] <- NA
  }
  
  last_label <- this_label
}

resdf$rna_prop_diff <- rna_prop_diff

df <- resdf[, c('cluster','pair','gene_i_symbol', 'gene_j_symbol', 'prop_diff', 'rna_prop_diff')]

idx <- sample(1:109837, size=1000)

#plot(x=df$prop_diff[idx], y=df$rna_prop_diff[idx])
head(df)

write.csv(resdf, file='../results/annotdf_m_rna_diff.csv.gz')

```


```{r}


resdf <- read_csv(file='../results/annotdf_m_rna_diff.csv.gz')

load('../data/M_processed_data.rda')

### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


# preparing for the scoring

x <- resdf$avg_dist_cluster

resdf$norm_avg_dist_cluster <- (  (x-median(x)) / (max(x) - min(x))  )

y <- resdf$avg_dist_not_cluster

resdf$norm_avg_dist_not_cluster <- (  (y-median(y)) / (max(y) - min(y))  )


# create the values that will be used to order pairs.
score0 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


# create the values that will be used to order pairs.
score1 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (1 - abs(resdf$prop_diff - resdf$rna_prop_diff))*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


resdf$score2 <- (score1 + abs(min(score1, na.rm = T))) / abs(max(score1,na.rm = T))

scoredf <- data.frame(score0=score0, score1=score1)
idx <- sample(1:356000, size=10000)
ggplot(data=scoredf[idx,], aes(y=score1, x=score0)) + geom_point() + xlim(c(0,1.1)) +  ylim(c(0,1.1)) + geom_abline()


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  k <- 2 # decending the ordered pairs table
  
  pwant <- wanted_pairs
  
  pairs <- resdf[(resdf$cluster == this_cluster),]
  
  #min_i_tval <- quantile(pairs$gene_i_min, na.rm=T)['50%']
  #min_j_tval <- quantile(pairs$gene_j_min, na.rm=T)['50%']


  #pairs <- pairs[(pairs$gene_i_min > min_i_tval) &
  #               (pairs$gene_j_min > min_j_tval),]


  # then we get the ordering index
  idx <- order(pairs$score2, decreasing = T)
  pairsord <- pairs[idx,]
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1],     pr=pairsord$rna_prop_diff[k],
                    sc=pairsord$score2[1])
  
  kmax <- nrow(pairsord)


  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, 
                      g1=pairsord$gene_i_symbol[k], g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k],     pr=pairsord$rna_prop_diff[k],
                      sc=pairsord$score2[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_m, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/males_genepairs_rna.rda')
  
```








First training the full model with all male data.
```{r}

# see data set up
load('../data/M_processed_data.rda')
load('../results/males_genepairs_rna.rda')

```


```{r}

gpairs <- shorter_and_clean(mgenepairs$val, 24)
genepairs_cl <- clean_genepairs_list(gpairs, dat_m)  # only one with missing genes
genepairs_cl <- clean_genepairs_list(genepairs_cl, val_m)  # only one with missing genes

# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=12,   # "height" of the tree, 6 is actually default.   (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values , more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher~ conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)

mod_m <- robencla::Robencla$new('m_model')

mod_m$train(data_frame=dat_m,
            label_name='ClusterLabel', #'ClusterLabel',
            sample_id = 'Barcode',
            drop_list = c(),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl, #genepairs_cl, # c3_pairs  # subset to these genes.
            params=params1
            )


# run the model
mod_m$predict(data_frame = val_m,
              sample_id = 'Barcode')



table(mod_m$results()$BestCall)
#cluster1 cluster2 cluster3 cluster5 
#      18      199       83      236 
      
# get the results table
resdf <- mod_m$results()
# add in the survival and censored
resdf$Survival <- mod_m$test_data$Survival
resdf$Censored <- mod_m$test_data$Censored

# convert scores to numerics
resdf$cluster1 <- unlist(resdf$cluster1)
resdf$cluster2 <- unlist(resdf$cluster2)
resdf$cluster3 <- unlist(resdf$cluster3)
resdf$cluster4 <- unlist(resdf$cluster4)
resdf$cluster5 <- unlist(resdf$cluster5)

resdf$CensoredCode <- ifelse(resdf$Censored == 0, yes=1, no=2)

modfit <- survfit(Surv(Survival, CensoredCode)~BestCalls,data=resdf)
ggsurvplot(modfit, pval = T, xlim=c(0,1700))
ggsave('../figures/males_validation_survival_curve_refined_features.pdf')


val_dat <- as.data.frame(mod_m$test_data)
val_dat$ClusterLabel <- resdf$BestCalls

```

```{r}

# test the validation array annotations for accuracy!
# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=12,   # "height" of the tree, 6 is actually default.   (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values , more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher~ conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_m2 <- robencla::Robencla$new('m_model')

mod_m2$train(data_frame=val_dat,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'Barcode',
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_m2$predict(data_frame = dat_m, 
              sample_id  = 'Barcode',
              label_name = 'ClusterLabel')




## check results
tabdf <- table(Pred=mod_m2$results()$BestCall, True=mod_m2$test_label)
print(tabdf)


# make the heatmap
tabtbl <- as.data.frame(tabdf) %>% 
  pivot_wider(id_cols = Pred, names_from = True, values_from = Freq) %>% 
  select(-Pred) #%>%
  #scale(center = F) # Z-scores
rownames(tabtbl) <- colnames(tabtbl)#c("cluster1","cluster2","cluster3","cluster5")

p <- pheatmap(tabtbl, cluster_rows = F, cluster_cols = F, display_numbers = T, 
              scale = 'column', fontsize_number = 12)



metrics <- mod_m2$classification_metrics(these_labels = mod_m2$test_label, these_calls = mod_m2$results()$BestCall,use_cv_results = F)

metrics

write_csv(metrics, file='../results/males_ValPred_to_TCGA_metrics_step4_5.csv')

save_pheatmap_pdf(p, "../figures/males_ValPred_to_TCGA_heatmap_step_4_5.pdf", width=5, height=5)

save(mod_m2, file='../results/models/M_ValPred_to_TCGA_step4_5.rda')

```
