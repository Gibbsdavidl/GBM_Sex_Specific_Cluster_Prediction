---
title: "Feature revision"
output: html_notebook
---

After the JIVE validation, we saw that some features do not reproduce well
in the validation studies. We will try to revise the selection to find
concordance.

```{r}
library(tidyverse)
library(robencla)
library(survminer)
library(survival)

# Take the data set, and filter out pair genes that are not present.

clean_genepairs_list <- function(genepairs, dat_x) {
  genepairs_clean <- list()
  i <- 1
  for (pi in names(genepairs)) {
    genes <- genepairs[[pi]]
    missing_genes <- unique( genes [! genes %in% colnames(dat_x)] )
    print(paste0(pi, '  ', missing_genes))
    newpairlist <- c()
    for (j in seq.int(from=1,to=length(genes), by=2)) {
      if ( (genes[j] %in% missing_genes) | (genes[j+1] %in% missing_genes) ) {
        # then don't add them!
        print(paste0("removing from pair list:  ", genes[j], ' ', genes[j+1]))
      } else {
        newpairlist <- c(newpairlist, genes[j], genes[j+1])
      }
    }
    genepairs_clean[[pi]] <- newpairlist
  }
  return(genepairs_clean)
}

# pairlist is a list of vectors (paired terms)
# n is the number of pairs for each entry desired

shorter_plist <- function(pairlist, n) {
  newlist <- list()
  for (ni in names(pairlist)) {
    newlist[[ni]] <- pairlist[[ni]][1:(2*n)]
  }
  return(newlist)  
}


```

First we load the array data, the validation data, the pairs table,
the selected gene pairs.

```{r}
Sys.setenv("VROOM_CONNECTION_SIZE" = 131072 * 2)

load('../results/females_genepairs_val.rda')
resdf <- read_csv('../results/annotdf_f.csv.gz')

dat_f <- read_csv('../data/jive_training_array_data_F.csv.gz')
dat_f <- dat_f[,-1] # remove the first column

val_f1 <- read_csv('../data/Array Data/jive_validation_16011_F.csv.gz')
val_f1$Survival <- as.numeric(val_f1$Survival) * 30.437

val_f2 <- read_csv('../data/Array Data/validation_array_gse108474_F.csv.gz')
val_f2$Survival <- as.numeric(val_f2$Survival) * 30.437

# survival was in days
val_f3 <- read_csv('../data/Array Data/jive_validation_13041_ex3_F_v2.csv.gz')
val_f3$Censored <- val_f3$Censored-1

# "fix" a couple columns
gidx <- which(colnames(val_f1) == 'LGALS2')
colnames(val_f1)[gidx] <- 'LGALS3'
gidx <- which(colnames(val_f1) == 'GFOD3P')
colnames(val_f1)[gidx] <- 'TP73-AS1'
gidx <- which(colnames(val_f2) == 'SubjectID')
colnames(val_f2)[gidx] <- 'SampleID'  # like the other data sets
```

Then we combine all the validation data together.

```{r}

colnames(dat_f)[which(colnames(dat_f) == 'Barcode')] <- 'SampleID'


gene_int <- intersect(colnames(dat_f), intersect(colnames(val_f1), intersect(colnames(val_f2), colnames(val_f3))))
val_f <- rbind(val_f1[,gene_int], val_f2[,gene_int])
val_f <- rbind(val_f, val_f3[,gene_int])
arr_f <- dat_f[,c(gene_int,'ClusterLabel')]


gene_int_val <- intersect( colnames(val_f1), intersect(colnames(val_f2), colnames(val_f3)))
val_f <- rbind(val_f1[,gene_int_val], val_f2[,gene_int_val])
val_f <- rbind(val_f, val_f3[,gene_int_val])


rm(array_f, val_f1, val_f2, val_f3, dat_f)

save(val_f, file = '../data/joined_validation_array_data_F.rda')

```



```{r}
load('data/joined_validation_array_data_F.rda')
load('data/tcga_array_data_F.rda')

load('data/rnaseq_tcga_F.rdaz')

load('../results/results_median_min/females_genepairs.rda')
gp1 <- genepairs
load('../results/females_genepairs_val.rda')
gp2 <- genepairs
load('../results/females_genepairs_rna.rda')
gp3 <- genepairs
resdf <- read_csv('../results/annotdf_f.csv.gz')


```


```{r}

gpairs <- shorter_plist(genepairs, 12)

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, val_f)  # only one with missing genes


# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_f <- robencla::Robencla$new('f_model')


mod_f$train(data_frame=dat_f,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'Barcode',
            drop_list = c('Sex'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_f$predict(data_frame = val_f, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


# assign the predicted cluster label
val_dat <- mod_f$test_data
val_dat$ClusterLabel <- mod_f$results()$BestCall

```

Now we can check the prop_diff between the training and testing data





```{r}

val_prop_diff <- c()
dat_prop_diff <- c()

this_label <- 'cluster1'
gp_cl <- genepairs[[this_label]]

for (rowi in seq.int(from=1, to = length(gp_cl), by = 2)) {

  # gene symbols
  #g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  #g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  g1 <- gp_cl[rowi]
  g2 <- gp_cl[rowi+1]
  
  if (g1 %in% colnames(val_dat) && g2 %in% colnames(val_dat)) {
    #  index into this cluster
    idx <- val_dat$ClusterLabel == this_label
    jdx <- val_dat$ClusterLabel != this_label
    
    # data labeled as THIS cluster
    labdat <- val_dat[idx,]
    # data labels as NOT THIS cluster
    notdat <- val_dat[jdx,]
    
    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
    
    # get the row for this gene pair
    resdf_idx <- which(resdf$cluster == this_label & resdf$gene_i_symbol == g1 & resdf$gene_j_symbol == g2)
    
    val_prop_diff <- c(val_prop_diff, prop1 - prop2)
    dat_prop_diff <- c(dat_prop_diff, resdf$prop_diff[resdf_idx])
  
  } else {
    print(
      "not found"
    )
  }
}

resdf[29077,c('cluster','pair','gene_i_symbol', 'gene_j_symbol', 'prop_diff')]

qplot(x=dat_prop_diff, y=val_prop_diff)

```





```{r}

rna_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))

last_label <- "asdf"

for (rowi in 1:nrow(resdf)) {
  
  if(rowi %% 1000 == 0){
    print(rowi)
  }

  this_label <- as.character(resdf$cluster[rowi])

  if (this_label != last_label) {
    #  index into this cluster
    idx <- tcga_f$cluster.group == this_label
    jdx <- tcga_f$cluster.group != this_label
    
    # data labeled as THIS cluster
    labdat <- as.data.table(tcga_f[idx,])
    # data labels as NOT THIS cluster
    notdat <- as.data.table(tcga_f[jdx,])

    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
  }
  
  # gene symbols
  g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  if (g1 %in% colnames(tcga_f) & g2 %in% colnames(tcga_f)) {
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
        
    rna_prop_diff[rowi] <- prop1 - prop2

  } else {
    rna_prop_diff[rowi] <- NA
  }
  
  last_label <- this_label
}

resdf$rna_prop_diff <- rna_prop_diff

#write_csv(resdf, file='../results/annotdf_f_valdiff.csv')



df <- resdf[, c('cluster','pair','gene_i_symbol', 'gene_j_symbol', 'prop_diff', 'rna_prop_diff')]

df[29077,]

idx <- sample(1:356000, size=1000)

qplot(x=df$prop_diff[idx], y=df$rna_prop_diff[idx])
head(df)
```



VAL ARRAY


```{r}

val_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))
tra_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))

last_label <- "asdf"

for (rowi in 1:nrow(resdf)) {
  
  if(rowi %% 1000 == 0){
    print(rowi)
  }

  this_label <- as.character(resdf$cluster[rowi])

  if (this_label != last_label) {
    #  index into this cluster
    idx <- val_dat$ClusterLabel == this_label
    jdx <- val_dat$ClusterLabel != this_label
    kdx <- dat_f$ClusterLabel == this_label
    ldx <- dat_f$ClusterLabel != this_label
    
    # data labeled as THIS cluster
    labdat <- val_dat[idx,]
    # data labels as NOT THIS cluster
    notdat <- val_dat[jdx,]
    # data labeled as THIS cluster
    labdat_tra <- dat_f[kdx,]
    # data labels as NOT THIS cluster
    notdat_tra <- dat_f[ldx,]
    
    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
        # number of samples in each category
    p <- sum(kdx)
    q <- sum(ldx)
  }
  
  # gene symbols
  g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  if (g1 %in% colnames(val_dat) & g2 %in% colnames(val_dat)) {
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
        # proportion of samples showing pattern gene1 > gene2    
    prop3 <- (sum(labdat_tra[, ..g1] > labdat_tra[, ..g2])/p) # proportion i>j in this cluster
    prop4 <- (sum(notdat_tra[, ..g1] > notdat_tra[, ..g2])/q) # proportion i>j in others
    
    val_prop_diff[rowi] <- prop1 - prop2
    tra_prop_diff[rowi] <- prop3 - prop4
  
  } else {
    val_prop_diff[rowi] <- NA
    tra_prop_diff[rowi] <- NA

  }
  
  last_label <- this_label
}

#resdf$val_prop_diff <- val_prop_diff

#write_csv(resdf, file='../results/annotdf_f_valdiff.csv')

```


```{r}
array_f <- read_csv('../data/jive_training_array_data_F.csv.gz')
array_f <- array_f[,-1] # remove the first column
```





RNA 


```{r}



### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


# preparing for the scoring

x <- resdf$avg_dist_cluster
resdf$norm_avg_dist_cluster <- (  (x-median(x)) / (max(x) - min(x))  )
y <- resdf$avg_dist_not_cluster
resdf$norm_avg_dist_not_cluster <- (  (y-median(y)) / (max(y) - min(y))  )


# create the values that will be used to order pairs.
score0 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


# create the values that will be used to order pairs.
score1 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (1 - abs(resdf$prop_diff - resdf$rna_prop_diff))*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


resdf$score2 <- (score1 + abs(min(score1, na.rm = T))) / abs(max(score1,na.rm = T))

scoredf <- data.frame(score0=score0, score1=score1)
idx <- sample(1:356000, size=10000)
ggplot(data=scoredf[idx,], aes(y=score1, x=score0)) + geom_point() + xlim(c(0,1.1)) +  ylim(c(0,1.1)) + geom_abline()


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- resdf[(resdf$cluster == this_cluster),]
  
  #min_i_tval <- quantile(pairs$gene_i_min, na.rm=T)['50%']
  #min_j_tval <- quantile(pairs$gene_j_min, na.rm=T)['50%']


  #pairs <- pairs[(pairs$gene_i_min > min_i_tval) &
  #               (pairs$gene_j_min > min_j_tval),]


  # then we get the ordering index
  idx <- order(pairs$score2, decreasing = T)
  pairsord <- pairs[idx,]
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], pr=pairsord$rna_prop_diff[k],
                    sc=pairsord$score2[1])
  
  kmax <- nrow(pairsord)

  k <- 2 # decending the ordered pairs table
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, g1=pairsord$gene_i_symbol[k], g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], pr=pairsord$rna_prop_diff[k],
                      sc=pairsord$score2[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_f, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/females_genepairs_rna.rda')
  
```




```{r}



### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


# preparing for the scoring

x <- resdf$avg_dist_cluster
resdf$norm_avg_dist_cluster <- (  (x-median(x)) / (max(x) - min(x))  )
y <- resdf$avg_dist_not_cluster
resdf$norm_avg_dist_not_cluster <- (  (y-median(y)) / (max(y) - min(y))  )


# create the values that will be used to order pairs.
score0 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


# create the values that will be used to order pairs.
score1 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (1 - abs(resdf$prop_diff - resdf$val_prop_diff))*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


resdf$score2 <- (score1 + abs(min(score1, na.rm = T))) / abs(max(score1,na.rm = T))

scoredf <- data.frame(score0=score0, score1=score1)
idx <- sample(1:356000, size=10000)
ggplot(data=scoredf[idx,], aes(y=score1, x=score0)) + geom_point() + xlim(c(0,1.1)) +  ylim(c(0,1.1)) + geom_abline()


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- resdf[(resdf$cluster == this_cluster),]
  
  min_i_tval <- quantile(pairs$gene_i_min, na.rm=T)['50%']
  min_j_tval <- quantile(pairs$gene_j_min, na.rm=T)['50%']


  pairs <- pairs[(pairs$gene_i_min > min_i_tval) &
                 (pairs$gene_j_min > min_j_tval),]


  # then we get the ordering index
  idx <- order(pairs$score2, decreasing = T)
  pairsord <- pairs[idx,]
  
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], iv=pairsord$score2[1])
  
  kmax <- nrow(pairsord)

  k <- 2 # decending the ordered pairs table
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, g1=pairsord$gene_i_symbol[k], g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], iv=pairsord$score2[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_f, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/females_genepairs_val.rda')
  
```


```{r}

#load('../results/females_genepairs_val.rda')

# new gene pairs
gpairs <- shorter_plist(genepairs, 12)

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, val_f)  # only one with missing genes


# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=6,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.3,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.1,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=1.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.1,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_f <- robencla::Robencla$new('f_model')


mod_f$train(data_frame=dat_f,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'SampleID',
            drop_list = c('Sex'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_f$predict(data_frame = val_f, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


rownames(val_f) <- val_f$SampleID
pheno_reorg <- val_f[mod_f$results()$SampleIDs, c("SampleID","Sex","Survival","Censored")]


res0 <- cbind(pheno_reorg, mod_f$results())
res0$Survival <- as.numeric(res0$Survival)

colnames(res0)[6] <- "Clus"

modfit <- survfit(Surv(Survival,Censored)~Clus,data=res0)
surp <- ggsurvplot(modfit, pval = T,xlim=c(0,1700))
surp

#ggsave("../figures/survplot_validation_refined_features_F.pdf", surp$plot, height = 5, width = 10)

```

```{r}
reslist <- numeric(8)
i <- 1

for (pi in c(3, 6, 9, 12, 15, 18, 21, 24)) {
  #load('../results/females_genepairs_val.rda')

  
# new gene pairs
gpairs <- shorter_plist(genepairs, 12)

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, val_f)  # only one with missing genes


# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=6,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.3,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.1,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=1.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.1,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_f <- robencla::Robencla$new('f_model')


mod_f$train(data_frame=val_dat,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'SampleID',
            drop_list = c('Sex'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_f$predict(data_frame = dat_f, 
              label_name = 'ClusterLabel',
              sample_id = 'SampleID',
              drop_list = c('Sex'))


cl_test <- mod_f$test_label

cl_pred <- mod_f$results()$BestCall

mat <- as.matrix(table(cl_test, cl_pred))
reslist[i] <- sum(diag(mat)) / sum(mat)
i <- i+1
}
#print(reslist)

#write.csv(mat, file='../results/tcga_pred_trained_on_val_conf_mat_F.csv')
```














 MEN










 
 
 

First we load the array data, the validation data, the pairs table,
the selected gene pairs.

```{r}
Sys.setenv("VROOM_CONNECTION_SIZE" = 131072 * 2)

load('../results/results_median_min/males_genepairs.rda')

resdf <- read_csv('../results/annotdf_m.csv.gz')

dat_m <- read_csv('../data/jive_training_array_data_M.csv.gz')
dat_m <- dat_m[,-1] # remove the first column

val_m1 <- read_csv('../data/Array Data/jive_validation_16011_M.csv.gz')
val_m1$Survival <- as.numeric(val_m1$Survival) * 30.437

val_m2 <- read_csv('../data/Array Data/validation_array_gse108474_M.csv.gz')
val_m2$Survival <- as.numeric(val_m2$Survival) * 30.437

# survival was in days
val_m3 <- read_csv('../data/Array Data/jive_validation_13041_ex3_M_v2.csv.gz')
val_m3$Censored <- val_m3$Censored-1

# "fix" a couple columns
gidx <- which(colnames(val_m1) == 'LGALS2')
colnames(val_m1)[gidx] <- 'LGALS3'
gidx <- which(colnames(val_m1) == 'GFOD3P')
colnames(val_m1)[gidx] <- 'TP73-AS1'
gidx <- which(colnames(val_m2) == 'SubjectID')
colnames(val_m2)[gidx] <- 'SampleID'  # like the other data sets
```

Then we combine all the validation data together.

```{r}

colnames(dat_m)[which(colnames(dat_m) == 'Barcode')] <- 'SampleID'


gene_int <- intersect(colnames(dat_m), intersect(colnames(val_m1), intersect(colnames(val_m2), colnames(val_m3))))
val_m <- rbind(val_m1[,gene_int], val_m2[,gene_int])
val_m <- rbind(val_m, val_m3[,gene_int])
arr_m <- dat_m[,c(gene_int,'ClusterLabel')]


gene_int_val <- intersect( colnames(val_m1), intersect(colnames(val_m2), colnames(val_m3)))
val_m <- rbind(val_m1[,gene_int_val], val_m2[,gene_int_val])
val_m <- rbind(val_m, val_m3[,gene_int_val])


#rm(array_f, val_f1, val_f2, val_f3, dat_f)

save(val_m, file='../data/joined_validation_array_data_M.rda')

```




```{r}


gpairs <- shorter_plist(genepairs, 12)

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, val_m)  # only one with missing genes


# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_m <- robencla::Robencla$new('m_model')


mod_m$train(data_frame=dat_m,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'Barcode',
            drop_list = c('Sex'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_m$predict(data_frame = val_m, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


# assign the predicted cluster label
val_dat <- mod_m$test_data
val_dat$ClusterLabel <- mod_m$results()$BestCall

```



```{r}

val_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))
tra_prop_diff <- vector(mode = 'numeric', length=nrow(resdf))

last_label <- "asdf"

for (rowi in 1:nrow(resdf)) {
  
  if(rowi %% 1000 == 0){
    print(rowi)
  }

  this_label <- as.character(resdf$cluster[rowi])

  if (this_label != last_label) {
    #  index into this cluster
    idx <- val_dat$ClusterLabel == this_label
    jdx <- val_dat$ClusterLabel != this_label
    kdx <- dat_m$ClusterLabel == this_label
    ldx <- dat_m$ClusterLabel != this_label
    
    # data labeled as THIS cluster
    labdat <- val_dat[idx,]
    # data labels as NOT THIS cluster
    notdat <- val_dat[jdx,]
    # data labeled as THIS cluster
    labdat_tra <- as.data.table(dat_m[kdx,])
    # data labels as NOT THIS cluster
    notdat_tra <- as.data.table(dat_m[ldx,])
    
    # number of samples in each category
    m <- sum(idx)
    n <- sum(jdx)
        # number of samples in each category
    p <- sum(kdx)
    q <- sum(ldx)
  }
  
  # gene symbols
  g1 <- as.character(resdf[rowi, 'gene_i_symbol'])
  g2 <- as.character(resdf[rowi, 'gene_j_symbol'])
  
  if (g1 %in% colnames(val_dat) & g2 %in% colnames(val_dat)) {
    
    # proportion of samples showing pattern gene1 > gene2    
    prop1 <- (sum(labdat[, ..g1] > labdat[, ..g2])/m) # proportion i>j in this cluster
    prop2 <- (sum(notdat[, ..g1] > notdat[, ..g2])/n) # proportion i>j in others
        # proportion of samples showing pattern gene1 > gene2    
    prop3 <- (sum(labdat_tra[, ..g1] > labdat_tra[, ..g2])/p) # proportion i>j in this cluster
    prop4 <- (sum(notdat_tra[, ..g1] > notdat_tra[, ..g2])/q) # proportion i>j in others
    
    val_prop_diff[rowi] <- prop1 - prop2
    tra_prop_diff[rowi] <- prop3 - prop4
  
  } else {
    val_prop_diff[rowi] <- NA
    tra_prop_diff[rowi] <- NA

  }
  
  last_label <- this_label
}

resdf$val_prop_diff <- val_prop_diff

write_csv(resdf, file='../results/annotdf_m_valdiff.csv')

```



```{r}



### number of pairs that we want.
wanted_pairs <- 24

# by ordering the table by prop_diff * avg_dist_cluster * avg_dist_not_cluster
# we are getting gene pairs with high proportions per cluster status
# and on average, the distance between genes is high effect.

# 1. prop diff must be high
# 2. effect size must be high for within and outside of cluster
# 3. direction of differences must be opposite for within and outside of cluster.
# 3. reduce correlation across feature set, same gene picked many times..

# return the corrleation with the previously selected pairs
getcors <- function(pairordtable, datatable, selected, proposal) {
  corlist <- list()
  for (k in 1:nrow(selected)) {
    cor1 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g1]) # correlation with last pair
    cor2 <- cor(datatable[,gp1$g1[k]], datatable[,gpk$g2]) # correlation with last pair
    cor3 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g1]) # correlation with last pair
    cor4 <- cor(datatable[,gp1$g2[k]], datatable[,gpk$g2]) # correlation with last pair
    corlist[[k]] <- c(cor1, cor2, cor3, cor4)
  }
  return(corlist)
}

# convert the list of tables to genepairs list
tab2list <- function(dflist) {
  pairslist <- list()
  for (ci in names(dflist)) {
    df <- dflist[[ci]]
    genepairs <- c()
    for (k in 1:nrow(df)) {
      genepairs <- c(genepairs, c(df[k,'g1'], df[k,'g2']))
    }
    pairslist[[ci]] <- genepairs
  }
  return(pairslist)
}


# preparing for the scoring

x <- resdf$avg_dist_cluster
resdf$norm_avg_dist_cluster <- (  (x-median(x)) / (max(x) - min(x))  )
y <- resdf$avg_dist_not_cluster
resdf$norm_avg_dist_not_cluster <- (  (y-median(y)) / (max(y) - min(y))  )


# create the values that will be used to order pairs.
score0 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


# create the values that will be used to order pairs.
score1 <- abs(resdf$prop_diff)*  # want as close to 1 as possible
          (1 - abs(resdf$prop_diff - resdf$val_prop_diff))*  # want as close to 1 as possible
          (-1* (resdf$avg_dist_cluster*resdf$avg_dist_not_cluster)) # must be in opposite directions


resdf$score2 <- (score1 + abs(min(score1, na.rm = T))) / abs(max(score1,na.rm = T))

scoredf <- data.frame(score0=score0, score1=score1)
idx <- sample(1:109000, size=10000)
ggplot(data=scoredf[idx,], aes(y=score1, x=score0)) + geom_point() + xlim(c(0,1.1)) +  ylim(c(0,1.1)) + geom_abline()


res0 <- list()

for (this_cluster in c('cluster1','cluster2','cluster3','cluster4','cluster5')) {
  
  pwant <- wanted_pairs
  
  pairs <- resdf[(resdf$cluster == this_cluster),]
  
  min_i_tval <- quantile(pairs$gene_i_min, na.rm=T)['50%']
  min_j_tval <- quantile(pairs$gene_j_min, na.rm=T)['50%']


  pairs <- pairs[(pairs$gene_i_min > min_i_tval) &
                 (pairs$gene_j_min > min_j_tval),]


  # then we get the ordering index
  idx <- order(pairs$score2, decreasing = T)
  pairsord <- pairs[idx,]
  
  
  # start with the top
  gp1 <- data.frame(k=1, 
                    g1=pairsord$gene_i_symbol[1], g2=pairsord$gene_j_symbol[1], 
                    pd=pairsord$prop_diff[1], iv=pairsord$score2[1])
  
  kmax <- nrow(pairsord)

  k <- 2 # decending the ordered pairs table
  # for each row in the ordered pairs table
  while (pwant > 0 & k < kmax) {
    
    # proposal: add this pair
    gpk <- data.frame(k=k, g1=pairsord$gene_i_symbol[k], g2=pairsord$gene_j_symbol[k], 
                      pd=pairsord$prop_diff[k], iv=pairsord$score2[k])
  
    # check with previously selected pairs
    corlist <- getcors(pairsord, dat_m, gp1, gpk)
    
    # if all correlation are low, accept the proposal
    if ( all( unlist( lapply(corlist, function(a) abs( a < 0.85 ))) ) )  {
      gp1 <- rbind(gp1, gpk)
      pwant <- pwant-1
      print(c(k, pwant))
    }
    
    k <- k+1
  }
  
  res0[[this_cluster]] <- gp1
}

genepairs <- tab2list(res0)

save(genepairs, res0, file='../results/males_genepairs_val.rda')
  
```


```{r}

#load('../results/females_genepairs_val.rda')

# new gene pairs
gpairs <- shorter_plist(genepairs, 24)

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, val_m)  # only one with missing genes



# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.3,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=1.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)



mod_m <- robencla::Robencla$new('m_model')


mod_m$train(data_frame=dat_m,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'SampleID',
            drop_list = c('Sex'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_m$predict(data_frame = val_m, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


rownames(val_m) <- val_m$SampleID
pheno_reorg <- val_m[mod_m$results()$SampleIDs, c("SampleID","Sex","Survival","Censored")]


res0 <- cbind(pheno_reorg, mod_m$results())
res0$Survival <- as.numeric(res0$Survival)

colnames(res0)[6] <- "Clus"

modfit <- survfit(Surv(Survival,Censored)~Clus,data=res0)
surp <- ggsurvplot(modfit, pval = T )
surp
ggsave("../figures/survplot_validation_refined_features_M.pdf", surp$plot, height = 5, width = 10)
```

```{r}

load('../results/males_genepairs_val.rda')

# new gene pairs
gpairs <- shorter_plist(genepairs, 24)

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, val_m)  # only one with missing genes


# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.3,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=1.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_m <- robencla::Robencla$new('m_model')


mod_m$train(data_frame=val_dat,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'SampleID',
            drop_list = c('Sex'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )


# run the model
mod_m$predict(data_frame = dat_m, 
              label_name = 'ClusterLabel',
              sample_id = 'SampleID',
              drop_list = c('Sex'))


cl_test <- mod_m$test_label

cl_pred <- mod_m$results()$BestCall

mat <- as.matrix(table(cl_test, cl_pred))
sum(diag(mat)) / sum(mat)

write.csv(mat, file='../results/tcga_pred_trained_on_val_conf_mat_M.csv')

mat
```



```{r}


############## checking the params ########################


genepairs_cl <- clean_genepairs_list(genepairs, dat_f2)

# our classifier object named Roberta
buffy <- Robencla$new("buffy")

# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


# First we use the training data
buffy$autocv(data_frame=dat_f2,
             label_name='ClusterLabel',
             sample_id = 'sample',
             drop_list = 'Sex',
             data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
             signatures=NULL,
             pair_list=genepairs_cl,  # subset to these genes.
             params=params,
             cv_rounds=10
)

buffy$classification_metrics()


```