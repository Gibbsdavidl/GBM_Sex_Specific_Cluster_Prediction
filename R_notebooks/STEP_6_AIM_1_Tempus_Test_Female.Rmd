---
title: An R Markdown document converted from "STEP_6_AIM_1_Tempus_Test.ipynb"
output: html_document
---

Changes:

* Subsetting to genes that are present in all data sources.. array, RNA-seq, and TEMPUS. 10363 genes.
* Subsetting the JIVE gene signatures to those present genes.

Questions: Are there missing genes, in array, that are present in RNA-seq, that would be better to have for TEMPUS?



```{r}
#devtools::install_github("gibbsdavidl/robencla", force = F)
```

```{r}
library(tidyverse)
library(robencla)
library(survival)
library(survminer)
```


```{r}

# Take the data set, and filter out pair genes that are not present.

clean_genepairs_list <- function(genepairs, dat_x) {
  genepairs_clean <- list()
  i <- 1
  for (pi in names(genepairs)) {
    genes <- genepairs[[pi]]
    missing_genes <- unique( genes [! genes %in% colnames(dat_x)] )
    print(paste0(pi, '  ', missing_genes))
    newpairlist <- c()
    for (j in seq.int(from=1,to=length(genes), by=2)) {
      if ( (genes[j] %in% missing_genes) | (genes[j+1] %in% missing_genes) ) {
        # then don't add them!
        print(paste0("removing from pair list:  ", genes[j], ' ', genes[j+1]))
      } else {
        newpairlist <- c(newpairlist, genes[j], genes[j+1])
      }
    }
    genepairs_clean[[pi]] <- newpairlist
  }
  return(genepairs_clean)
}

# pairlist is a list of vectors (paired terms)
# n is the number of pairs for each entry desired

shorter_plist <- function(pairlist, n) {
  newlist <- list()
  for (ni in names(pairlist)) {
    newlist[[ni]] <- pairlist[[ni]][1:(2*n)]
  }
  return(newlist)  
}



```


```{r}
Sys.setenv("VROOM_CONNECTION_SIZE" = 131072 * 2)
arr_f <- read_csv('../data/jive_training_array_data_F.csv.gz')
tmp_f <- read_csv('../data/Tempus_Females_unstranded.csv.gz')

load('../results/results_no_array_min/females_genepairs.rda')
gset1 <- genepairs
load('../results/females_genepairs.rda')
gset2 <- genepairs

tempus.clin <- read.csv('../data/TEMPUS_Clinical_Data.csv.gz')
```

```{r}

gpairs <- shorter_plist(gset1, 3)  # gset2 is NOT predictive!!

tmp_f[['RNASE4']]  <- NULL # has 0 var

lapply(gpairs, function(x) x[! (x %in% colnames(arr_f ))] )
lapply(gpairs, function(x) x[! (x %in% colnames(tmp_f))] ) # missing "FABP5"  "CD24"   "LGALS3"

# clean the pairs
genepairs_cl <- clean_genepairs_list(gpairs, tmp_f)  # only one with missing genes

gs1 <- c(unlist(unique(genepairs_cl)), "Barcode", "ClusterLabel")
gs2 <- c(unlist(unique(genepairs_cl)), "Barcode", "Survival", "Censored")

colnames(tmp_f)[19939:19940] <- c('Censored','Survival')
colnames(tmp_f)[1] <- 'Barcode'

dat_f <- arr_f[,gs1]
val_f <- tmp_f[,gs2]

# what if ...
dat_f$ClusterLabel2 <- ifelse(dat_f$ClusterLabel == 'cluster3', yes = 'C3', no='notC3')
c3_pairs <- list()
c3_pairs[['C3']] <- genepairs_cl$cluster3
c3_pairs[['notC3']] <- c(genepairs_cl$cluster1, genepairs_cl$cluster2, genepairs_cl$cluster4, genepairs_cl$cluster5)


# xgboost parameters to pass to each sub-classifier in the ensembles
# xgboost parameters to pass to each sub-classifier in the ensembles
params1 <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_f <- robencla::Robencla$new('f_model')

mod_f$train(data_frame=dat_f,
            label_name='ClusterLabel', #'ClusterLabel2',
            sample_id = 'Barcode',
            drop_list = c(),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # c3_pairs   # subset to these genes.
            params=params1
            )

# mod_f$train(data_frame=dat_f,
#             label_name='ClusterLabel2',
#             sample_id = 'Barcode',
#             drop_list = c('ClusterLabel'),
#             data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
#             signatures=NULL,         # 
#             pair_list=c3_pairs,  # c3_pairs   # subset to these genes.
#             params=params1
#             )
# 

# run the model
mod_f$predict(data_frame = val_f, 
              sample_id = 'Barcode',
              drop_list = c('Survival', 'Censored'))


# check the predictions
table(mod_f$results()$BestCall)

head(mod_f$results())

# reorder the tables
rownames(val_f) <- val_f$Barcode
pheno_reorg <- val_f[mod_f$results()$SampleIDs, c("Barcode","Survival","Censored")]

# now bind in the results to the phenotype data
resdf <- cbind(pheno_reorg, mod_f$results())
#resdf <- na.omit(resdf)
resdf$Survival <- as.numeric(resdf$Survival)

# resdf$C3 <- unlist(resdf$C3)
# resdf$notC3 <- unlist(resdf$notC3)
resdf$cluster1 <- unlist(resdf$cluster1)
resdf$cluster2 <- unlist(resdf$cluster2)
resdf$cluster3 <- unlist(resdf$cluster3)
resdf$cluster4 <- unlist(resdf$cluster4)
resdf$cluster5 <- unlist(resdf$cluster5)


resdf$CensoredCode <- ifelse(resdf$Censored == 'alive', yes=1, no=2)

modfit <- survfit(Surv(Survival, CensoredCode)~BestCalls,data=resdf)
ggsurvplot(modfit, pval = T)


# scores for the samples called cluster3
#boxplot(as.numeric(resdf$cluster3)~as.factor(resdf$BestCalls))


#boxplot(as.numeric(resdf$C3)~as.factor(resdf$BestCalls))

```




```{r}

# results list
resl <- list()
print('starting')

# for a number of iterations, could be more
for (i in 1:1000) {

  # randomly produce a training set
  idx <- sample(1:nrow(arr_f),size=5,replace = F)
  sampleidx <- arr_f$sample[idx]
  dfa3 <- arr_f[!(arr_f$sample %in% sampleidx), ]

  # our classifier object named Anne.
  anne <- Robencla$new("Anne")

  # xgboost parameters to pass to each sub-classifier in the ensembles
  params <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
                 eta=0.2,        # this is the learning rate. smaller values slow it down, more conservative   (xgboost parameter)
                 nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
                 nthreads=5,     # parallel threads
                 gamma=0.5,      # Minimum loss reduc req'd to again partition a leaf node. higher number ~ more conservative (xgboost parameter)
                 lambda=1.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
                 alpha=0.5,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
                 verbose=0,
                 train_perc=0.8,
                 combine_function='median',
                 size=11
  )

  # First we use the training data
  anne$autotrain(data_frame = dfa3,
                 label_name='cluster_group',
                 sample_id = 'sample',
                 data_mode=c('pairs','quartiles' ),  # pairs,sigpairs,quartiles,tertiles,binary,ranks,original #
                 pair_list=genelist,  # subset to these genes.
                 params=params,
                 verbose=0)

  # now we apply the classifier to a test set.
  anne$autotest(data_frame = tmp_f,
                label_name='cluster_group',
                sample_id = 'sample',
                verbose=0)

  df.f.tempus <- anne$results(include_label = T)
  df.f.tempus$cluster1 <- as.numeric(df.f.tempus$cluster1)
  df.f.tempus$cluster2 <- as.numeric(df.f.tempus$cluster2)
  df.f.tempus$cluster3 <- as.numeric(df.f.tempus$cluster3)
  df.f.tempus$cluster4 <- as.numeric(df.f.tempus$cluster4)
  df.f.tempus$cluster5 <- as.numeric(df.f.tempus$cluster5)
  resl[[i]] <- df.f.tempus
}

```


```{r}
# collect the results from all the runs
resdf <- do.call("rbind", resl)

# making one call per sample
samples <- unique(resdf$SampleIDs)
majvote <- data.frame()

for (si in samples) {
  restbl <- resdf %>% filter(SampleIDs == si) %>% select(BestCalls) %>% table()
  majvote <- rbind(majvote, data.frame(SampleIDs=si, MajorityVote=sample(names(restbl)[max(restbl) == restbl], size=1)))
}

majvote <- dplyr::inner_join(majvote, resdf, by='SampleIDs')

write.csv(majvote, file = 'female_tempus_pred_pairs_quantiles_1000_maj.csv')

table(MajVote=majvote$MajorityVote, BestCall=majvote$BestCalls)
```


```{r}
##
majvote$SampleIDs <- gsub("_"," ",majvote$SampleIDs)

## taking only the single majority vote for each sample with unique
tempus.clin.f.cluster <- inner_join(tempus.clin, unique(majvote[,c("SampleIDs","MajorityVote")]), by=c("Study.ID" = "SampleIDs"))
```


```{r}
t.f.fit <- survfit(Surv(Survival.months,Vital.Status)~MajorityVote,data=tempus.clin.f.cluster)
t.f.fit
```

```{r}
ggsurvplot(t.f.fit, pval = T)
```

```{r}
tempus.f <- tmp_f
tempus.f$sample <- gsub("_"," ",tempus.f$sample)

tempus.f.clus <- left_join(tempus.f[,c('sample','TIMP1','ID3')], df.f.tempus[,c("SampleIDs","BestCalls")], by = c("sample" = "SampleIDs"))  
tempus.f.clus.plot.data <- reshape2::melt(tempus.f.clus, na.rm = FALSE, value.name = "G.Exp", id = c('sample','BestCalls'))
```

```{r}
ggplot(data = tempus.f.clus.plot.data, aes(x=BestCalls, y=G.Exp, fill=BestCalls)) +
  geom_boxplot() + facet_wrap(~variable)
```

