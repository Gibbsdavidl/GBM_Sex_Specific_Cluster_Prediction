---
title: "STEP_4_5_AIM_1_JIVE_validation.Rmd"
output: html_document
date: "2023-10-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if(!require("survminer", quietly = TRUE))
  BiocManager::install("survminer")
  
if(!require("robencla", quietly=TRUE))
  devtools::install_github("gibbsdavidl/robencla", force = F)

```

## JIVE Validation

```{r}


# Take the data set, and filter out pair genes that are not present.

clean_genepairs_list <- function(genepairs, dat_x) {
  genepairs_clean <- list()
  i <- 1
  for (pi in names(genepairs)) {
    genes <- genepairs[[pi]]
    missing_genes <- unique( genes [! genes %in% colnames(dat_x)] )
    print(paste0(pi, '  ', missing_genes))
    newpairlist <- c()
    for (j in seq.int(from=1,to=length(genes), by=2)) {
      if ( (genes[j] %in% missing_genes) | (genes[j+1] %in% missing_genes) ) {
        # then don't add them!
        print(paste0("removing from pair list:  ", genes[j], ' ', genes[j+1]))
      } else {
        newpairlist <- c(newpairlist, genes[j], genes[j+1])
      }
    }
    genepairs_clean[[pi]] <- newpairlist
  }
  return(genepairs_clean)
}

```


First training the full model with all data.
```{r}

library(readr)
library(robencla)
Sys.setenv("VROOM_CONNECTION_SIZE" = 131072 * 2)

dat_f <- read_csv('../data/jive_training_array_data_F.csv.gz')

val_f <- read_csv('../data/Array Data/jive_validation_16011_F.csv.gz')

load("../results/females_genepairs_v3.rda")

lapply(genepairs, function(x) x[! (x %in% colnames(dat_f))] )
lapply(genepairs, function(x) x[! (x %in% colnames(val_f))] )

gidx <- which(colnames(val_f) == 'GFOD3P')
colnames(val_f)[gidx] <- 'TP73-AS1'

dat_f <- dat_f[,-1]

genepairs_cl <- clean_genepairs_list(genepairs, dat_f)
genepairs_cl <- clean_genepairs_list(genepairs_cl, val_f)

# what if ...
dat_f$ClusterLabel2 <- ifelse(dat_f$ClusterLabel == 'cluster3', yes = 'C3', no='notC3')
c3_pairs <- list()
c3_pairs[['C3']] <- genepairs_cl$cluster3
c3_pairs[['notC3']] <- c(genepairs_cl$cluster1, genepairs_cl$cluster2, genepairs_cl$cluster4, genepairs_cl$cluster5)

# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=6,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.2,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=12,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=6,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=1.2,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.2,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_f <- robencla::Robencla$new('f_model')


mod_f$train(data_frame=dat_f,
            label_name='ClusterLabel',
            sample_id = 'Barcode',
            drop_list = c('Sex'), #,'ClusterLabel'),
            data_mode=c('pairs'),    # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,         # 
            pair_list=genepairs_cl,  # subset to these genes.
            params=params
            )


# run the model
mod_f$predict(data_frame = val_f, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


table(mod_f$results()$BestCall)
## check results

# get them reordered
### selected females in order of results
rownames(val_f) <- val_f$SampleID
pheno3_reorg <- val_f[mod_f$results()$SampleIDs, c("SampleID","Sex","Survival","Censored")]

# now bind in the results to the phenotype data
resdf <- cbind(pheno3_reorg, mod_f$results())
resdf <- na.omit(resdf)
resdf$Survival <- as.numeric(resdf$Survival)

resdf$C3 <- unlist(resdf$C3)
resdf$notC3 <- unlist(resdf$notC3)

resdf$cluster1 <- unlist(resdf$cluster1)
resdf$cluster2 <- unlist(resdf$cluster2)
resdf$cluster3 <- unlist(resdf$cluster3)
resdf$cluster4 <- unlist(resdf$cluster4)
resdf$cluster5 <- unlist(resdf$cluster5)

write_csv(resdf, file='gse16011_results.csv')

boxplot(resdf$Survival ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check

c3_call <- ifelse(resdf$BestCall == 'cluster3', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(resdf$Survival ~ c3_call, 
        xlab='Model Prediction', ylab='Survival (days)')

library(survival)
library(survminer)

modfit <- survfit(Surv(Survival,Censored)~BestCalls,data=resdf)
ggsurvplot(modfit, pval = T)

ggsave('../figures/validation_survival_curve_F_16011.pdf')

```




16011 males

```{r}


library(readr)
library(robencla)

dat_m <- read_csv('../data/jive_training_array_data_M_v2.csv')

val_m <- read_csv('../data/Array Data/jive_validation_16011_M.csv')

load("../results/males_genepairs.rda")

# removing signature genes that are not available in our data sets
male.jive.gene.list <- readRDS("../data/Males_jive_cluster_genes.rds") %>% 
  dplyr::filter(value %in% colnames(dat_m)) %>%
  dplyr::filter(value %in% colnames(val_m))
  
genepairs_cl <- clean_genepairs_list(genepairs, dat_m)
genepairs_cl <- clean_genepairs_list(genepairs_cl, val_m)

lapply(genepairs_cl, function(x) sum(x %in% colnames(dat_m))/ length(x))


sigs.m <- list("C1"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster1'],
               "C2"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster2'],
               "C3"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster3'],
               "C4"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster4'],
               "C5"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster5']
)


# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=18,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.2,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=32,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=1.2,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.2,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_m <- robencla::Robencla$new('m_model')


mod_m$train(data_frame=dat_m,
            label_name='ClusterLabel',
            sample_id = 'Barcode',
            drop_list = c('Sex'),
            data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=sigs.m,
            pair_list=genepairs_cl,  # subset to these genes.
            params=params
            )


### to run the model, we need the same column names as in the training data
# but that's taken care of with pair cleaning ...

lapply(genepairs_cl, function(x) sum(x %in% colnames(val_m))/ length(x))

# run the model
mod_m$predict(data_frame = val_m, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


#mod_f$pred_table
#mod_f$results()
table(mod_m$results()$BestCall)
## check results

# get them reordered
### selected females in order of results
rownames(val_m) <- val_m$SampleID
pheno3_reorg <- val_m[mod_m$results()$SampleIDs, c("SampleID","Sex","Survival","Censored")]

# now bind in the results to the phenotype data
resdf <- cbind(pheno3_reorg, mod_m$results())
resdf <- na.omit(resdf)
resdf$Survival <- as.numeric(resdf$Survival)

boxplot(resdf$Survival ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check

c5_call <- ifelse(resdf$BestCall == 'cluster5', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(resdf$Survival ~ c5_call, 
        xlab='Model Prediction', ylab='Survival (days)')

library(survival)
library(survminer)

modfit <- survfit(Surv(Survival,Censored)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T)
ggsave('../figures/validation_survival_curve_M_16011.pdf')

```









Validation F REMBRANDT

```{r}

library(readr)
library(robencla)

library(survival)
library(survminer)

dat_f <- read_csv('../data/jive_training_array_data_F.csv')

val_f <- read_csv('../data/Array Data/validation_array_gse108474_F.csv.gz')

load("../results/females_genepairs_v2.rda")

dat_f <- dat_f[,-1]

# all genes present!
lapply(genepairs, function(x) x[! (x %in% colnames(dat_f))] )
lapply(genepairs, function(x) x[! (x %in% colnames(val_f))] )


# what if ...
dat_f$ClusterLabel2 <- ifelse(dat_f$ClusterLabel == 'cluster3', yes = 'C3', no='notC3')
c3_pairs <- list()
c3_pairs[['C3']] <- genepairs_cl$cluster3
c3_pairs[['notC3']] <- c(genepairs_cl$cluster1, genepairs_cl$cluster2, genepairs_cl$cluster4, genepairs_cl$cluster5)


# removing signature genes that are not available in our data sets
female.jive.gene.list <- readRDS("../data/Female_jive_cluster_genes.rds") %>% 
  dplyr::filter(value %in% colnames(dat_f)) %>%
  dplyr::filter(value %in% colnames(val_f))

sigs_f <- list("C1"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster1'],
               "C2"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster2'],
               "C3"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster3'],
               "C4"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster4'],
               "C5"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster5']
)

# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=6,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.3,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=12,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=6,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=1.2,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.2,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_f <- robencla::Robencla$new('f_model')


mod_f$train(data_frame=dat_f,
            label_name='ClusterLabel2',
            sample_id = 'Barcode',
            drop_list = c('Sex','ClusterLabel'),
            data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,
            pair_list=c3_pairs,  # subset to these genes.
            params=params
            )

#save(mod_f, file='../models/females_tcga_array_step4_5.rda')

### to run the model, we need the same column names as in the training data
# but that's taken care of with pair cleaning ...

mod_f$importance()

# run the model
mod_f$predict(data_frame = val_f, 
              sample_id = 'SubjectID',
              drop_list = c('Sex', 'Survival', 'Censored'))

## check results
table(mod_f$results()$BestCall)

# get them reordered
### selected females in order of results
vidx <- match(val_f$SubjectID, mod_f$results()$SampleIDs)
all(val_f$SubjectID == mod_f$results()$SampleIDs[vidx], na.rm=T)
#data.frame(val_f$SubjectID, mod_f$results()$SampleIDs[vidx])

pheno <- val_f[, c("SubjectID","Sex","Censored","Survival")]


# now bind in the results to the phenotype data
resdf <- cbind(pheno, mod_f$results()[vidx,])
resdf$Survival <- as.numeric(resdf$Survival)
resdf$Censored <- as.numeric(resdf$Censored)


boxplot(resdf$Survival ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check

c3_call <- ifelse(resdf$BestCall == 'cluster3', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(resdf$Survival ~ c3_call, 
        xlab='Model Prediction', ylab='Survival (days)')

modfit <- survfit(Surv(Survival,Censored)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T)
ggsave('../figures/validation_survival_curve_F_gse108474.pdf')

```






Validation M REMBRANDT

```{r}

library(readr)
library(robencla)

library(survival)
library(survminer)

dat_m <- read_csv('../data/jive_training_array_data_M_v2.csv')

val_m <- read_csv('../data/Array Data/validation_array_gse108474_M.csv')

load("../results/males_genepairs.rda")

# where did NPEPPS go?
# NPEPPS

# GFOD3P has alias in the array data:
which(colnames(val_f) == 'TP73-AS1')
#[1] 14418
colnames(val_f)[14418] <- 'GFOD3P'

### clean up the genepairs
genepairs_cl <- clean_genepairs_list(genepairs, dat_f)
genepairs_cl <- clean_genepairs_list(genepairs_cl, val_f)

## check for feature matches
lapply(genepairs, function(x) sum(x %in% colnames(dat_f)))
lapply(genepairs, function(x) sum(x %in% colnames(val_f)))
lapply(genepairs,    function(x) x[!(x %in% colnames(dat_f))] )
lapply(genepairs,    function(x) x[!(x %in% colnames(val_f))] )
lapply(genepairs_cl, function(x) x[!(x %in% colnames(val_f))])


# removing signature genes that are not available in our data sets
female.jive.gene.list <- readRDS("../data/Female_jive_cluster_genes.rds") %>% 
  dplyr::filter(value %in% colnames(dat_f)) %>%
  dplyr::filter(value %in% colnames(val_f))

sigs_f <- list("C1"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster1'],
               "C2"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster2'],
               "C3"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster3'],
               "C4"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster4'],
               "C5"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster5']
)

# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_m <- robencla::Robencla$new('m_model')


mod_m$train(data_frame=dat_m,
            label_name='ClusterLabel',
            sample_id = 'Barcode',
            drop_list = c('Sex'),
            data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,
            pair_list=genepairs_cl,  # subset to these genes.
            params=params
            )

#save(mod_f, file='../models/females_tcga_array_step4_5.rda')

### to run the model, we need the same column names as in the training data
# but that's taken care of with pair cleaning ...

mod_m$importance()

# run the model
mod_m$predict(data_frame = val_m, 
              sample_id = 'SubjectID',
              drop_list = c('Sex', 'Survival', 'Censored'))

#mod_f$pred_table
#mod_f$results()
table(mod_m$results()$BestCall)
## check results

# get them reordered
### selected females in order of results
vidx <- match(val_m$SubjectID, mod_m$results()$SampleIDs)
all(val_m$SubjectID == mod_m$results()$SampleIDs[vidx], na.rm=T)
#data.frame(val_f$SubjectID, mod_f$results()$SampleIDs[vidx])

pheno <- val_m[, c("SubjectID","Sex","Censored","Survival")]


# now bind in the results to the phenotype data
resdf <- cbind(pheno, mod_m$results()[vidx,])
resdf$Survival <- as.numeric(resdf$Survival)
resdf$Censored <- as.numeric(resdf$Censored)


boxplot(resdf$Survival ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check

c5_call <- ifelse(resdf$BestCall == 'cluster5', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(resdf$Survival ~ c5_call, 
        xlab='Model Prediction', ylab='Survival (days)')


modfit <- survfit(Surv(Survival,Censored)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T)
ggsave('../figures/validation_survival_curve_F_13041.pdf')

```










Validation F 13041

```{r}

library(readr)
library(robencla)

library(survival)
library(survminer)

dat_f <- read_csv('../data/jive_training_array_data_F_v2.csv')

val_f <- read_csv('../data/Array Data/jive_validation_13041_ex3_F_v2.csv.gz')

load("../results/females_genepairs_v2.rda")


### clean up the genepairs
genepairs_cl <- clean_genepairs_list(genepairs, dat_f)
genepairs_cl <- clean_genepairs_list(genepairs_cl, val_f)

## check for feature matches
lapply(genepairs, function(x) sum(x %in% colnames(dat_f)))
lapply(genepairs, function(x) sum(x %in% colnames(val_f)))
lapply(genepairs,    function(x) x[!(x %in% colnames(val_f))] )
lapply(genepairs_cl, function(x) x[!(x %in% colnames(val_f))])


# removing signature genes that are not available in our data sets
female.jive.gene.list <- readRDS("../data/Female_jive_cluster_genes.rds") %>% 
  dplyr::filter(value %in% colnames(dat_f)) %>%
  dplyr::filter(value %in% colnames(val_f))

sigs_f <- list("C1"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster1'],
               "C2"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster2'],
               "C3"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster3'],
               "C4"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster4'],
               "C5"=female.jive.gene.list$value[female.jive.gene.list$cluster.group == 'cluster5']
)

# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.35,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_f <- robencla::Robencla$new('f_model')


mod_f$train(data_frame=dat_f,
            label_name='ClusterLabel2',
            sample_id = 'Barcode',
            drop_list = c('Sex','ClusterLabel'),
            data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,
            pair_list=genepairs_cl,  # subset to these genes.
            params=params
            )

#save(mod_f, file='../models/females_tcga_array_step4_5.rda')

### to run the model, we need the same column names as in the training data
# but that's taken care of with pair cleaning ...

mod_f$importance()


# run the model
mod_f$predict(data_frame = val_f, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))

#mod_f$pred_table
#mod_f$results()
table(mod_f$results()$BestCall)
## check results

# get them reordered
### selected females in order of results
rownames(val_f) <- val_f$SampleID
pheno3_reorg <- val_f[mod_f$results()$SampleIDs, c("SampleID","Sex","Survival","Censored")]

# now bind in the results to the phenotype data
resdf <- cbind(pheno3_reorg, mod_f$results())
resdf <- na.omit(resdf)
resdf$Survival <- as.numeric(resdf$Survival)

boxplot(resdf$Survival ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check

c3_call <- ifelse(resdf$BestCall == 'cluster3', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(resdf$Survival ~ c3_call, 
        xlab='Model Prediction', ylab='Survival (days)')


modfit <- survfit(Surv(Survival,Censored)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T)
ggsave('../figures/validation_survival_curve_F_13041.pdf')

```




13041 males

```{r}


library(readr)
library(robencla)
library(survival)
library(survminer)

dat_m <- read_csv('../data/jive_training_array_data_M_v2.csv')

val_m <- read_csv('../data/Array Data/jive_validation_13041_ex3_M_v2.csv')

load("../results/males_genepairs.rda")

# removing signature genes that are not available in our data sets
male.jive.gene.list <- readRDS("../data/Males_jive_cluster_genes.rds") %>% 
  dplyr::filter(value %in% colnames(dat_m)) %>%
  dplyr::filter(value %in% colnames(val_m))
  
genepairs_cl <- clean_genepairs_list(genepairs, dat_m)
genepairs_cl <- clean_genepairs_list(genepairs_cl, val_m)

lapply(genepairs, function(x) sum(x %in% colnames(dat_m)))
lapply(genepairs, function(x) sum(x %in% colnames(val_m)))
lapply(genepairs_cl, function(x) x[! (x %in% colnames(val_m))] )

sigs.m <- list("C1"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster1'],
               "C2"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster2'],
               "C3"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster3'],
               "C4"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster4'],
               "C5"=male.jive.gene.list$value[male.jive.gene.list$cluster.group == 'cluster5']
)


# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=18,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
               eta=0.45,        # this is the learning rate. smaller values slow it down, more  conservative   (xgboost parameter)
               nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
               early_stopping_rounds=2,
               nthreads=8,     # parallel threads
               gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
               lambda=2.5,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
               alpha=0.25,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
               verbose=0,
               train_perc=0.8,
               combine_function='median',
               size=11
)


mod_m <- robencla::Robencla$new('m_model')


mod_m$train(data_frame=dat_m,
            label_name='ClusterLabel',
            sample_id = 'Barcode',
            drop_list = c('Sex'),
            data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,
            pair_list=genepairs_cl,  # subset to these genes.
            params=params
            )


mod_m$importance()


# run the model
mod_m$predict(data_frame = val_m, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


#mod_f$pred_table
#mod_f$results()
table(mod_m$results()$BestCall)
## check results

# get them reordered
### selected females in order of results
rownames(val_m) <- val_m$SampleID
pheno3_reorg <- val_m[mod_m$results()$SampleIDs, c("SampleID","Sex","Survival","Censored")]

# now bind in the results to the phenotype data
resdf <- cbind(pheno3_reorg, mod_m$results())
resdf <- na.omit(resdf)
resdf$Survival <- as.numeric(resdf$Survival)

boxplot(resdf$Survival ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check
c5_call <- ifelse(resdf$BestCall == 'cluster5', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(resdf$Survival ~ c5_call, 
        xlab='Model Prediction', ylab='Survival (days)')



modfit <- survfit(Surv(Survival,Censored)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T)
ggsave('../figures/validation_survival_curve_M_13041.pdf')

```


