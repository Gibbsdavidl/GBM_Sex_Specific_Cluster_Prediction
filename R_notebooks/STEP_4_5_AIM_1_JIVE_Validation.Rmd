---
title: "STEP_4_5_AIM_1_JIVE_validation.Rmd"
output: html_document
date: "2023-10-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if(!require("survminer", quietly = TRUE))
  BiocManager::install("survminer")
  
devtools::install_github("gibbsdavidl/robencla", force = T)

```

## JIVE Validation

```{r}
clean_genepairs_list <- function(genepairs, dat_x) {
  
  genepairs_clean <- list()
  i <- 1
  for (pi in names(genepairs)) {
    genes <- genepairs[[pi]]
    missing_genes <- unique( genes [! genes %in% colnames(dat_x)] )
    print(paste0(pi, '  ', missing_genes))
    newpairlist <- c()
    for (j in seq.int(from=1,to=length(genes), by=2)) {
      if ( (genes[j] %in% missing_genes) | (genes[j+1] %in% missing_genes) ) {
        # then don't add them!
        print(paste0("removing from pair list:  ", genes[j], ' ', genes[j+1]))
      } else {
        newpairlist <- c(newpairlist, genes[j], genes[j+1])
      }
    }
    genepairs_clean[[pi]] <- newpairlist
  }
  return(genepairs_clean)
}

```


First training the full model with all data.
```{r}

library(readr)
library(robencla)

dat_f <- read_csv('../data/jive_training_array_data_F_v2.csv')

load("../results/females_genepairs.rda")

genepairs_cl <- clean_genepairs_list(genepairs, dat_f)
genepairs_cl <- clean_genepairs_list(genepairs_cl, val_F)


lapply(genepairs_cl, function(x) sum(x %in% colnames(dat_f))/ length(x))

#dat_f <- dat_f[, ! colnames(dat_f) %in% c('Sex',')]

# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
                 eta=0.4,        # this is the learning rate. smaller values slow it down, more conservative   (xgboost parameter)
                 nrounds=24,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
                 early_stopping_rounds=2,
                 nthreads=5,     # parallel threads
                 gamma=0.2,      # Minimum loss req'd to again partition a leaf node. higher number ~ more conservative (xgboost)
                 lambda=1.2,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
                 alpha=0.2,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
                 verbose=0,
                 train_perc=0.8,
                 combine_function='median',
                 size=11
  )

mod_f <- robencla::Robencla$new('f_model')


mod_f$train(data_frame=dat_f,
            label_name='ClusterLabel',
            sample_id = 'Barcode',
            drop_list = c('Sex'),
            data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,
            pair_list=genepairs_cl,  # subset to these genes.
            params=params
            )

#save(mod_f, file='../models/females_tcga_array_step4_5.rda')

```




In the JIVE manuscript, there are three array expression data sets used for validation:
 GSE13041, GSE16011, and REMBRANDT

See: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE55918
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE13041
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE16011
https://link.springer.com/article/10.1007/s13402-014-0190-8#Sec20


```{r}

val_F <- read_csv('../data/Array Data/jive_validation_16011_F.csv')


### to run the model, we need the same column names as in the training data

lapply(genepairs_cl, function(x) sum(x %in% colnames(val_F))/ length(x))
lapply(genepairs_cl, function(x) x[ !(x %in% colnames(val_F))] ) 

# run the model
mod_f$predict(data_frame = val_F, 
              sample_id = 'SampleID',
              drop_list = c('Sex'))


mod_f$pred_table
mod_f$results()
table(mod_f$results()$BestCall)
## check results

# get them reordered

val_F[1:5, 17529:17532]

### selected females in order of results
rownames(val_F) <- val_F$SampleID
pheno3_reorg <- val_F[mod_f$results()$SampleIDs, c("SampleID","Sex","Survival","Censored")]

# now bind in the results to the phenotype data
resdf <- cbind(pheno3_reorg, mod_f$results())
resdf <- na.omit(resdf)

boxplot(as.numeric(resdf$Survival) ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check

c3_call <- ifelse(resdf$BestCall == 'cluster3', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(as.numeric(resdf$Survival) ~ c3_call, 
        xlab='Model Prediction', ylab='Survival (days)')

library(survival)
library(survminer)

modfit <- survfit(Surv(Survival,Censored)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T)

```


males

```{r}

load('../data/validation_array_data/pheno13041.rda')

load('../data/validation_array_data/GSE13041_mat3.rda')

# load up the gene pairs used
load('../results/males_genepairs.rda')


# check what genes might be missing
unlist(genepairs) [! unlist(genepairs) %in% colnames(mat3) ]

# for males
#cluster113  cluster28 cluster210  cluster46 
#     "CIT"    "TMED7"   "CHMP4A"    "PFDN6" 

CIT_alias <- c("CIT", 'STK21', 'CRIK', 'KIAA0949', 'CITK', 'MCPH17') 

sapply(CIT_alias, function(a) {
  any(str_detect(string = colnames(mat3), pattern=a))
})

colnames(mat3) [
  which(str_detect(string = colnames(mat3), pattern="CIT"))
]

which(str_detect(string = colnames(mat3), pattern="CIT"))
 
colnames(mat3)[12186] <- "CIT"  #  "MIR1178///CIT" 



TMED7_alias <- c("TMED7") 

sapply(TMED7_alias, function(a) {
  any(str_detect(string = colnames(mat3), pattern=a))
})

colnames(mat3) [
  which(str_detect(string = colnames(mat3), pattern="TMED7"))
]

which(str_detect(string = colnames(mat3), pattern="TMED7"))

cor(mat3[,8897], mat3[,14034])

#8897, 14034
colnames(mat3)[14034] <- "TMED7"  # "TMED7-TICAM2///TMED7"



TMED7_alias <- c("PFDN6") 

sapply(TMED7_alias, function(a) {
  any(str_detect(string = colnames(mat3), pattern=a))
})

colnames(mat3) [
  which(str_detect(string = colnames(mat3), pattern="PFDN6"))
]

which(str_detect(string = colnames(mat3), pattern="PFDN6"))
#21379 21389
colnames(mat3)[21389] <- "PFDN6"  # "MIR6834///PFDN6" 



CHMP4A_alias <- c("CHMP4A") 

sapply(CHMP4A_alias, function(a) {
  any(str_detect(string = colnames(mat3), pattern=a))
})

colnames(mat3) [
  which(str_detect(string = colnames(mat3), pattern="CHMP4A"))
]

which(str_detect(string = colnames(mat3), pattern="CHMP4A"))
#17936 17937
colnames(mat3)[17937] <- "CHMP4A" # "CHMP4A///TM9SF1"



### build the data set with the gene pairs

expr_m <- mat3[, unique(unlist(genepairs))]
expr_m[["sample"]] <- rownames(expr_m)


### split into male and females

m_idx <- which(pheno3$sex == 'gender: M')

m_ids <- pheno3$id[pheno3$sex == 'gender: M']

expr_m <- expr_m[m_ids,]

# save data
save(expr_m, file='../data/GSE13041_mat3_m.rda.rda')


###


dat_m <- read_csv('../data/Males_Array_Data.csv.gz')

# xgboost parameters to pass to each sub-classifier in the ensembles
params <- list(max_depth=12,   # "height" of the tree, 6 is actually default. I think about 12 seems better.  (xgboost parameter)
                 eta=0.2,        # this is the learning rate. smaller values slow it down, more conservative   (xgboost parameter)
                 nrounds=32,     # number of rounds of training, lower numbers less overfitting (potentially)  (xgboost parameter)
                 early_stopping_rounds=2,
                 nthreads=5,     # parallel threads
                 gamma=0.1,      # Minimum loss reduc req'd to again partition a leaf node. higher number ~ more conservative (xgboost parameter)
                 lambda=1.1,     # L2 regularization term on weights, higher number ~ more conservative (xgboost parameter)
                 alpha=0.1,      # L1 regularization term on weights. higher number ~ more conservative (xgboost parameter)
                 verbose=0,
                 train_perc=0.8,
                 combine_function='median',
                 size=11
  )

mod_m <- robencla::Robencla$new('m_model')

mod_m$train(data_frame=dat_m,
            label_name='cluster_group',
            sample_id = 'sample',
            data_mode=c('pairs'), # pairs, allpairs, sigpairs, quartiles, tertiles, binarize, ranks, original #
            signatures=NULL,
            pair_list=genepairs,  # subset to these genes.
            params=params
            )

mod_m$predict(data_frame = dat_m, sample_id = 'sample', label_name = 'cluster_group')

table(mod_m$test_label, mod_m$results()$BestCall)  ## OK!


## check results

mod_m$predict(data_frame = expr_m, sample_id = 'sample')

table(mod_m$results()$BestCall)  ## OK!


# get them reordered

### selected females in order of results
rownames(pheno3) <- pheno3$id
pheno3_reorg <- pheno3[mod_m$results()$SampleIDs,]

resdf <- cbind(pheno3_reorg, mod_m$results())

boxplot(resdf$days ~ resdf$BestCall, 
        xlab='Model Prediction', ylab='Survival (days)')

   
# extra check

c5_call <- ifelse(resdf$BestCall == 'cluster5', yes=1, no=0) #ifelse(mod_f$pred_table$cluster3 > 0.8, yes=1, no=0)

boxplot(resdf$days ~ c5_call, 
        xlab='Model Prediction', ylab='Survival (days)')

library(survival)
library(survminer)

modfit <- survfit(Surv(days,status)~BestCalls,data=resdf)

ggsurvplot(modfit, pval = T)

```


